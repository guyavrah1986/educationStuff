// ==================================================================================================================================================
// 
// 1) This includes the GENERATED header file from its RESPECTIVE .proto file, i.e.- before building this project ONLY this cpp file
//    and the basicProtobufProtoFile.proto files exsits.This .pb.h file is one (among more) file which is generated by the 
//    protoc compiler.
//
// 2) Verify that the version of the library that we linked against is compatible with the version of the headers we compiled.
//
// 3) Create a stack based object from our message definition. Note: We "prefixed" it with the namespace it is located in.
//
// 4) It is possible to define an "inner" message as a filed of another "hosting" message.
// a) The "inner" message filed has been initialized when we created its "outer" message (where it is resides).
// b) In order to set it, we need to use this "setter", cause the "normal one" will return us a const& so we won't be able to 
//    modify it.
//
// 5) Using oneof keyword: Very similar to C/C++ union. We can use it in order to "minimze" memory consumption of our message
//    to only a specific filed at any time.
// a) In this line of code, we are "giving up" on the single int value we added to the repeatedUnsignedInt filed of 
//    our SampleMessageUsingOneOf object, and letting it "know" we NOW wish to use the oneOfStr filed. 
// b) IMPORTANT: When one of the fileds within the "oneof" is a message, after "giving up" on him for any other filed of 
//    the oneof - it will point to "NULL" memory so using it, like so, will cause a crash to our program.
//
// 6) Usage in the CopyFrom method which is part of the basic API for all PB (Protocol Buffer) classes.
//
// 7) Serialize the message into a binary form. Note, that although the result is places in a std::string object, it is still
//    only holds the message's content in a binary from.
//
// 8) Parse "back" (retrieve/read) a message form a std::string obejct.
//
// 9) General notes regarding extending a protocol buffer:
//    In the new version of the protocol buffer:
//    - you must not change the tag numbers of any existing fields.
//    - you must not add or delete any required fields.
//    - you may delete optional or repeated fields.
//    - you may add new optional or repeated fields but you must use fresh tag numbers(i.e.tag numbers that were never used
//    in this protocol buffer, not even by deleted fields).
//
// ==================================================================================================================================================
#include <iostream>
#include <string>

#include "basicProtobufProtoFile.pb.h" // 1)

using namespace std;

void basicInitialSettings(basicMessageTutorial::BasicMessage& msg)
{
	cout << "basicInitialSettings - got msg object with address:" << &msg << endl;
	if (msg.IsInitialized() == false)
	{
		cout << "basicInitialSettings - msg (of type BasicMessage) is NOT initialized" << endl;
	}
	else
	{
		cout << "basicInitialSettings - msg (of type BasicMessage) is initialized" << endl;
	}

	// string singularString = 1
	msg.set_singularstring("sampleSingularString");

	// int32 singularInt = 2
	msg.set_singularint(17);

	// repeated string repeatedStrings = 3
	size_t numOfStringsAdded = 0;
	msg.add_repeatedstrings("sampleFirstString");
	++numOfStringsAdded;
	msg.add_repeatedstrings("sampleSecondString");
	++numOfStringsAdded;
	cout << "basicInitialSettings - after adding " << numOfStringsAdded << " strings to the repeatedStrings filed"
		" msg.add_repeatedstrings.size() is:" << msg.repeatedstrings_size() << endl;

	// SimpleEnum singularEnum = 4
	msg.set_singularenum(msg.FIFTH_VAL);

	if (msg.nestedmsg().IsInitialized() == true) // 4a) 
	{
		cout << "basicInitialSettings - the inner message type nestedmsg is initialized" << endl;
	}
	else
	{
		cout << "basicInitialSettings - the inner message type nestedmsg is NOT initialized" << endl;
	}
	
	// BasicNestedMessage nestedMsg = 5
	msg.mutable_nestedmsg()->set_singularnestedstring("simpleNestedString");	// 4b) 
}

void usingOneOfKeywordExample()
{
	cout << "usingOneOfKeywordExample - creating a SampleMessageUsingOneOf message in the stack" << endl;
	basicMessageTutorial::SampleMessageUsingOneOf oneOfMsg;
	basicMessageTutorial::BasicNestedMessage* nestedMsg = oneOfMsg.mutable_oneofnestedmsg();
	nestedMsg->add_repeatedunsignedint(23);
	cout << "usingOneOfKeywordExample - after setting the oneOfNestedMsg::repeatedUnsignedInt with a first value"
		" oneOfMsg.DebugString() displays:" << oneOfMsg.DebugString() << endl;

	oneOfMsg.set_oneofstr("sampleOneOfStr");	// 5a)
	cout << "usingOneOfKeywordExample - after setting the oneOfMsg::oneOfStr (string) filed, it oneOfMsg.DebugString()" 
		" displays:" << oneOfMsg.DebugString() << endl;

	// 5b)
	// nestedMsg->add_repeatedunsignedint(12);	
}

void parsingAndSerializationExample()
{
	cout << "parsingAndSerializationExample - creating a BasicMessage on the function stack" << endl;
	basicMessageTutorial::BasicMessage msg1;

	// string singularString = 1
	msg1.set_singularstring("sampleSingularString");

	// int32 singularInt = 2
	msg1.set_singularint(17);

	// repeated string repeatedStrings = 3
	msg1.add_repeatedstrings("sampleFirstRepeatedString");
	msg1.add_repeatedstrings("sampleSecondRepeatedString");

	// SimpleEnum singularEnum = 4
	msg1.set_singularenum(msg1.FIFTH_VAL);

	// BasicNestedMessage nestedMsg = 5
	msg1.mutable_nestedmsg()->set_singularnestedstring("simpleNestedString");
	msg1.mutable_nestedmsg()->add_repeatedunsignedint(15);
	msg1.mutable_nestedmsg()->add_repeatedunsignedint(17);

	cout << "parsingAndSerializationExample - after setting msg1 with some values it is set to:"
		<< msg1.DebugString() << endl;

	basicMessageTutorial::BasicMessage msg2;
	msg2.CopyFrom(msg1);	// 6)
	cout << "parsingAndSerializationExample - after copying from msg1, msg2 is set to" << msg2.DebugString() << endl;

	string serializedStringOfMsg1;
	if (msg1.SerializeToString(&serializedStringOfMsg1) == true)	// 7)
	{
		cout << "parsingAndSerializationExample - successfully serialized msg1 into a string:" << serializedStringOfMsg1 << endl;
	}
	else
	{
		cout << "parsingAndSerializationExample - was unable to serialize msg1 into a string" << endl;
	}

	msg2.Clear();
	if (msg2.ParseFromString(serializedStringOfMsg1) == true)	// 8)
	{
		cout << "parsingAndSerializationExample - successfully parsed the serializedStringOfMsg1 string into msg2"
			" which is set to:" << msg2.DebugString() << endl;
	}
	else
	{
		cout << "parsingAndSerializationExample - was unable to parse the serializedStringOfMsg1 string into msg2" << endl;
	}
}

int main(int argc, char* argv[]) 
{
	GOOGLE_PROTOBUF_VERIFY_VERSION;	// 2)

	basicMessageTutorial::BasicMessage msg;	// 3) 
	cout << "main - BEFORE calling basicInitialSettings msg.DebugString() displays:" << msg.DebugString() << endl;
	basicInitialSettings(msg);
	cout << "main - AFTER calling basicInitialSettings msg.DebugString() displays:" << msg.DebugString() << endl;
	usingOneOfKeywordExample();
	parsingAndSerializationExample();

	// Optional:  Delete all global objects allocated by libprotobuf.
	google::protobuf::ShutdownProtobufLibrary();

	char c;
	cout << "main - enter any key terminate and hit ENTER" << endl;
	cin >> c;
	return 0;
}
